from collections import deque

def bfs(start, target, maps):
    n, m = len(maps), len(maps[0])
    visited = [[False]*m for _ in range(n)]
    dx, dy = (-1,1,0,0), (0,0,-1,1)
    q = deque()
    q.append((start[0], start[1], 0))
    visited[start[0]][start[1]] = True
    
    while q:
        x, y, dist = q.popleft()
        if maps[x][y] == target:
            return dist
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < n and 0 <= ny < m:
                if maps[nx][ny] != "X" and not visited[nx][ny]:
                    visited[nx][ny] = True
                    q.append((nx, ny, dist+1))
    return -1

def solution(maps):
    n, m = len(maps), len(maps[0])
    # 시작(S), 레버(L), 출구(E) 찾기
    for i in range(n):
        for j in range(m):
            if maps[i][j] == "S":
                start = (i,j)
            elif maps[i][j] == "L":
                lever = (i,j)
            elif maps[i][j] == "E":
                end = (i,j)
    
    # S → L
    dist1 = bfs(start, "L", maps)
    if dist1 == -1:
        return -1
    
    # L → E
    dist2 = bfs(lever, "E", maps)
    if dist2 == -1:
        return -1
    
    return dist1 + dist2


print(solution(["SOOOL","XXXXO","OOOOO","OXXXX","OOOOE"]))  # ✅ 16
