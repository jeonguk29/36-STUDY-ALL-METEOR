from collections import deque


# 2단계 bfs 코드
def bfs(place, row, col):

    ny = (-1, 1, 0, 0)
    nx = (0, 0, -1, 1)

    visited =[[False] * 5 for _ in range(5)]
    q = deque()
    visited[row][col] = True
    q.appendleft((row, col, 0)) # 시작 거리는 0 자기자신

    while q:
        y, x, dist = q.popleft()
				
		# 거리가 2 초과시 더이상 탐색 필요 x 거리를 지키고 있다는 것임
        if dist > 2:
            continue
        # 시작위치가 아니고 다른 응시자를 만나면 (위 조건 때문에 거리가 2 이하이면서)
        if dist != 0 and place[y][x] == 'P':
            return False
        
        # 거리 돌면서 (상하좌우)
        for i in range(4):
            nextY = y + ny[i]
            nextX = x + nx[i]

            # 좌표 벋어나면 skip
            if nextY < 0 or nextY > 4 or nextX < 0 or nextX > 4:
                continue
            # 큐에 넣은적 있다면 skip
            if visited[nextY][nextX]:
                continue
            # 파티션 만나면 이동 못함
            if place[nextY][nextX] == 'X':
                continue
            # 여기까지 오면 이동가능 다음 좌표 큐에 추가
            visited[nextY][nextX] = True
            q.append((nextY, nextX, dist + 1))
            
    return True # 조건 다 통과시 거리두기 지키거 있어서 True 반환

# 1단계 스테이지별 체크 코드
def check(place):
    for r in range(5):
        for c in range(5):
            if place[r][c] == 'P': #P를 찾으면 bfs 
                if bfs(place, r, c) == False: # 응시자 위치 넘기기 다른 응시자 안만나면 True
                    return False
    return True # 각 대기실 응시자 없어도 참 반환

def solution(places):
    answer = []
    for place in places:
        if check(place):
            answer.append(1)
        else:
            answer.append(0)

    return answer

print(solution([["POOOP", "OXXOX", "OPXPX", "OOXOX", "POXXP"], ["POOPX", "OXPXP", "PXXXO", "OXXXO", "OOOPP"], ["PXOPX", "OXOXP", "OXPOX", "OXXOP", "PXPOX"], ["OOOXX", "XOOOX", "OOOXX", "OXOOX", "OOOOO"], ["PXPXP", "XPXPX", "PXPXP", "XPXPX", "PXPXP"]]))